// Autogenerated by Thrift Compiler (0.11.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package edam

import (
	"bytes"
	"reflect"
	"database/sql/driver"
	"errors"
	"context"
	"fmt"
	"github.com/apache/thrift/lib/go/thrift"

)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = context.Background
var _ = reflect.DeepEqual
var _ = bytes.Equal

//* Numeric codes indicating the type of error that occurred on the
//* service.
//* <dl>
//*   <dt>UNKNOWN</dt>
//*     <dd>No information available about the error</dd>
//*   <dt>BAD_DATA_FORMAT</dt>
//*     <dd>The format of the request data was incorrect</dd>
//*   <dt>PERMISSION_DENIED</dt>
//*     <dd>Not permitted to perform action</dd>
//*   <dt>INTERNAL_ERROR</dt>
//*     <dd>Unexpected problem with the service</dd>
//*   <dt>DATA_REQUIRED</dt>
//*     <dd>A required parameter/field was absent</dd>
//*   <dt>LIMIT_REACHED</dt>
//*     <dd>Operation denied due to data model limit</dd>
//*   <dt>QUOTA_REACHED</dt>
//*     <dd>Operation denied due to user storage limit</dd>
//*   <dt>INVALID_AUTH</dt>
//*     <dd>Username and/or password incorrect</dd>
//*   <dt>AUTH_EXPIRED</dt>
//*     <dd>Authentication token expired</dd>
//*   <dt>DATA_CONFLICT</dt>
//*     <dd>Change denied due to data model conflict</dd>
//*   <dt>ENML_VALIDATION</dt>
//*     <dd>Content of submitted note was malformed</dd>
//*   <dt>SHARD_UNAVAILABLE</dt>
//*     <dd>Service shard with account data is temporarily down</dd>
//*   <dt>LEN_TOO_SHORT</dt>
//*     <dd>Operation denied due to data model limit, where something such
//*         as a string length was too short</dd>
//*   <dt>LEN_TOO_LONG</dt>
//*     <dd>Operation denied due to data model limit, where something such
//*         as a string length was too long</dd>
//*   <dt>TOO_FEW</dt>
//*     <dd>Operation denied due to data model limit, where there were
//*         too few of something.</dd>
//*   <dt>TOO_MANY</dt>
//*     <dd>Operation denied due to data model limit, where there were
//*         too many of something.</dd>
//*   <dt>UNSUPPORTED_OPERATION</dt>
//*     <dd>Operation denied because it is currently unsupported.</dd>
//*   <dt>TAKEN_DOWN</dt>
//*     <dd>Operation denied because access to the corresponding object is
//*         prohibited in response to a take-down notice.</dd>
//*   <dt>RATE_LIMIT_REACHED</dt>
//*     <dd>Operation denied because the calling application has reached
//*         its hourly API call limit for this user.</dd>
//*   <dt>BUSINESS_SECURITY_LOGIN_REQUIRED</dt>
//*     <dd>Access to a business account has been denied because the user must complete
//*        additional steps in order to comply with business security requirements.</dd>
//*   <dt>DEVICE_LIMIT_REACHED</dt>
//*     <dd>Operation denied because the user has exceeded their maximum allowed
//*        number of devices.</dd>
//*   <dt>OPENID_ALREADY_TAKEN</dt>
//*     <dd>Operation failed because the Open ID is already associated with another user.</dd>
//*   <dt>INVALID_OPENID_TOKEN</dt>
//*     <dd>Operation denied because the Open ID token is invalid. Please re-issue a valid
//*        token.</dd>
//*	 <dt>USER_NOT_REGISTERED</dt>
//*     <dd>There is no Evernote user associated with this OpenID account,
//*     	   and no Evernote user with a matching email</dd>
//*	 <dt>USER_NOT_ASSOCIATED</dt>
//*     <dd>There is no Evernote user associated with this OpenID account,
//*		   but Evernote user with matching email exists</dd>
//*	 <dt>USER_ALREADY_ASSOCIATED</dt>
//* 	   <dd>Evernote user is already associated with this provider
//*		   using a different email address.</dd>
//*	 <dt>ACCOUNT_CLEAR</dt>
//*     <dd>The user's account has been disabled. Clients should deal with this errorCode
//*       by logging the user out and purging all locally saved content, including local
//*       edits not yet pushed to the server.</dd>
//*	 <dt>SSO_AUTHENTICATION_REQUIRED</dt>
// *     <dd>SSO authentication is the only tyoe of authentication allowed for the user's
// *     account. This error is thrown when the user attempts to authenticate by another
//  *     method (password, OpenId, etc).</dd>
// * </dl>
type EDAMErrorCode int64
const (
  EDAMErrorCode_UNKNOWN EDAMErrorCode = 1
  EDAMErrorCode_BAD_DATA_FORMAT EDAMErrorCode = 2
  EDAMErrorCode_PERMISSION_DENIED EDAMErrorCode = 3
  EDAMErrorCode_INTERNAL_ERROR EDAMErrorCode = 4
  EDAMErrorCode_DATA_REQUIRED EDAMErrorCode = 5
  EDAMErrorCode_LIMIT_REACHED EDAMErrorCode = 6
  EDAMErrorCode_QUOTA_REACHED EDAMErrorCode = 7
  EDAMErrorCode_INVALID_AUTH EDAMErrorCode = 8
  EDAMErrorCode_AUTH_EXPIRED EDAMErrorCode = 9
  EDAMErrorCode_DATA_CONFLICT EDAMErrorCode = 10
  EDAMErrorCode_ENML_VALIDATION EDAMErrorCode = 11
  EDAMErrorCode_SHARD_UNAVAILABLE EDAMErrorCode = 12
  EDAMErrorCode_LEN_TOO_SHORT EDAMErrorCode = 13
  EDAMErrorCode_LEN_TOO_LONG EDAMErrorCode = 14
  EDAMErrorCode_TOO_FEW EDAMErrorCode = 15
  EDAMErrorCode_TOO_MANY EDAMErrorCode = 16
  EDAMErrorCode_UNSUPPORTED_OPERATION EDAMErrorCode = 17
  EDAMErrorCode_TAKEN_DOWN EDAMErrorCode = 18
  EDAMErrorCode_RATE_LIMIT_REACHED EDAMErrorCode = 19
  EDAMErrorCode_BUSINESS_SECURITY_LOGIN_REQUIRED EDAMErrorCode = 20
  EDAMErrorCode_DEVICE_LIMIT_REACHED EDAMErrorCode = 21
  EDAMErrorCode_OPENID_ALREADY_TAKEN EDAMErrorCode = 22
  EDAMErrorCode_INVALID_OPENID_TOKEN EDAMErrorCode = 23
  EDAMErrorCode_USER_NOT_ASSOCIATED EDAMErrorCode = 24
  EDAMErrorCode_USER_NOT_REGISTERED EDAMErrorCode = 25
  EDAMErrorCode_USER_ALREADY_ASSOCIATED EDAMErrorCode = 26
  EDAMErrorCode_ACCOUNT_CLEAR EDAMErrorCode = 27
  EDAMErrorCode_SSO_AUTHENTICATION_REQUIRED EDAMErrorCode = 28
)

func (p EDAMErrorCode) String() string {
  switch p {
  case EDAMErrorCode_UNKNOWN: return "UNKNOWN"
  case EDAMErrorCode_BAD_DATA_FORMAT: return "BAD_DATA_FORMAT"
  case EDAMErrorCode_PERMISSION_DENIED: return "PERMISSION_DENIED"
  case EDAMErrorCode_INTERNAL_ERROR: return "INTERNAL_ERROR"
  case EDAMErrorCode_DATA_REQUIRED: return "DATA_REQUIRED"
  case EDAMErrorCode_LIMIT_REACHED: return "LIMIT_REACHED"
  case EDAMErrorCode_QUOTA_REACHED: return "QUOTA_REACHED"
  case EDAMErrorCode_INVALID_AUTH: return "INVALID_AUTH"
  case EDAMErrorCode_AUTH_EXPIRED: return "AUTH_EXPIRED"
  case EDAMErrorCode_DATA_CONFLICT: return "DATA_CONFLICT"
  case EDAMErrorCode_ENML_VALIDATION: return "ENML_VALIDATION"
  case EDAMErrorCode_SHARD_UNAVAILABLE: return "SHARD_UNAVAILABLE"
  case EDAMErrorCode_LEN_TOO_SHORT: return "LEN_TOO_SHORT"
  case EDAMErrorCode_LEN_TOO_LONG: return "LEN_TOO_LONG"
  case EDAMErrorCode_TOO_FEW: return "TOO_FEW"
  case EDAMErrorCode_TOO_MANY: return "TOO_MANY"
  case EDAMErrorCode_UNSUPPORTED_OPERATION: return "UNSUPPORTED_OPERATION"
  case EDAMErrorCode_TAKEN_DOWN: return "TAKEN_DOWN"
  case EDAMErrorCode_RATE_LIMIT_REACHED: return "RATE_LIMIT_REACHED"
  case EDAMErrorCode_BUSINESS_SECURITY_LOGIN_REQUIRED: return "BUSINESS_SECURITY_LOGIN_REQUIRED"
  case EDAMErrorCode_DEVICE_LIMIT_REACHED: return "DEVICE_LIMIT_REACHED"
  case EDAMErrorCode_OPENID_ALREADY_TAKEN: return "OPENID_ALREADY_TAKEN"
  case EDAMErrorCode_INVALID_OPENID_TOKEN: return "INVALID_OPENID_TOKEN"
  case EDAMErrorCode_USER_NOT_ASSOCIATED: return "USER_NOT_ASSOCIATED"
  case EDAMErrorCode_USER_NOT_REGISTERED: return "USER_NOT_REGISTERED"
  case EDAMErrorCode_USER_ALREADY_ASSOCIATED: return "USER_ALREADY_ASSOCIATED"
  case EDAMErrorCode_ACCOUNT_CLEAR: return "ACCOUNT_CLEAR"
  case EDAMErrorCode_SSO_AUTHENTICATION_REQUIRED: return "SSO_AUTHENTICATION_REQUIRED"
  }
  return "<UNSET>"
}

func EDAMErrorCodeFromString(s string) (EDAMErrorCode, error) {
  switch s {
  case "UNKNOWN": return EDAMErrorCode_UNKNOWN, nil 
  case "BAD_DATA_FORMAT": return EDAMErrorCode_BAD_DATA_FORMAT, nil 
  case "PERMISSION_DENIED": return EDAMErrorCode_PERMISSION_DENIED, nil 
  case "INTERNAL_ERROR": return EDAMErrorCode_INTERNAL_ERROR, nil 
  case "DATA_REQUIRED": return EDAMErrorCode_DATA_REQUIRED, nil 
  case "LIMIT_REACHED": return EDAMErrorCode_LIMIT_REACHED, nil 
  case "QUOTA_REACHED": return EDAMErrorCode_QUOTA_REACHED, nil 
  case "INVALID_AUTH": return EDAMErrorCode_INVALID_AUTH, nil 
  case "AUTH_EXPIRED": return EDAMErrorCode_AUTH_EXPIRED, nil 
  case "DATA_CONFLICT": return EDAMErrorCode_DATA_CONFLICT, nil 
  case "ENML_VALIDATION": return EDAMErrorCode_ENML_VALIDATION, nil 
  case "SHARD_UNAVAILABLE": return EDAMErrorCode_SHARD_UNAVAILABLE, nil 
  case "LEN_TOO_SHORT": return EDAMErrorCode_LEN_TOO_SHORT, nil 
  case "LEN_TOO_LONG": return EDAMErrorCode_LEN_TOO_LONG, nil 
  case "TOO_FEW": return EDAMErrorCode_TOO_FEW, nil 
  case "TOO_MANY": return EDAMErrorCode_TOO_MANY, nil 
  case "UNSUPPORTED_OPERATION": return EDAMErrorCode_UNSUPPORTED_OPERATION, nil 
  case "TAKEN_DOWN": return EDAMErrorCode_TAKEN_DOWN, nil 
  case "RATE_LIMIT_REACHED": return EDAMErrorCode_RATE_LIMIT_REACHED, nil 
  case "BUSINESS_SECURITY_LOGIN_REQUIRED": return EDAMErrorCode_BUSINESS_SECURITY_LOGIN_REQUIRED, nil 
  case "DEVICE_LIMIT_REACHED": return EDAMErrorCode_DEVICE_LIMIT_REACHED, nil 
  case "OPENID_ALREADY_TAKEN": return EDAMErrorCode_OPENID_ALREADY_TAKEN, nil 
  case "INVALID_OPENID_TOKEN": return EDAMErrorCode_INVALID_OPENID_TOKEN, nil 
  case "USER_NOT_ASSOCIATED": return EDAMErrorCode_USER_NOT_ASSOCIATED, nil 
  case "USER_NOT_REGISTERED": return EDAMErrorCode_USER_NOT_REGISTERED, nil 
  case "USER_ALREADY_ASSOCIATED": return EDAMErrorCode_USER_ALREADY_ASSOCIATED, nil 
  case "ACCOUNT_CLEAR": return EDAMErrorCode_ACCOUNT_CLEAR, nil 
  case "SSO_AUTHENTICATION_REQUIRED": return EDAMErrorCode_SSO_AUTHENTICATION_REQUIRED, nil 
  }
  return EDAMErrorCode(0), fmt.Errorf("not a valid EDAMErrorCode string")
}


func EDAMErrorCodePtr(v EDAMErrorCode) *EDAMErrorCode { return &v }

func (p EDAMErrorCode) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *EDAMErrorCode) UnmarshalText(text []byte) error {
q, err := EDAMErrorCodeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *EDAMErrorCode) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = EDAMErrorCode(v)
return nil
}

func (p * EDAMErrorCode) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//An enumeration that provides a reason for why a given contact was invalid, for example,
//as thrown via an EDAMInvalidContactsException.
//
//<dl>
//  <dt>BAD_ADDRESS</dt>
//    <dd>The contact information does not represent a valid address for a recipient.
//        Clients should be validating and normalizing contacts, so receiving this
//        error code commonly represents a client error.
//        </dd>
//  <dt>DUPLICATE_CONTACT</dt>
//    <dd>If the method throwing this exception accepts a list of contacts, this error
//        code indicates that the given contact is a duplicate of another contact in
//        the list.  Note that the server may clean up contacts, and that this cleanup
//        occurs before checking for duplication.  Receiving this error is commonly
//        an indication of a client issue, since client should be normalizing contacts
//        and removing duplicates. All instances that are duplicates are returned.  For
//        example, if a list of 5 contacts has the same e-mail address twice, the two
//        conflicting e-mail address contacts will be returned.
//        </dd>
//  <dt>NO_CONNECTION</dt>
//    <dd>Indicates that the given contact, an Evernote type contact, is not connected
//        to the user for which the call is being made. It is possible that clients are
//        out of sync with the server and should re-synchronize their identities and
//        business user state. See Identity.userConnected for more information on user
//        connections.
//        </dd>
//</dl>
//
//Note that if multiple reasons may apply, only one is returned. The precedence order
//is BAD_ADDRESS, DUPLICATE_CONTACT, NO_CONNECTION, meaning that if a contact has a bad
//address and is also duplicated, it will be returned as a BAD_ADDRESS.
type EDAMInvalidContactReason int64
const (
  EDAMInvalidContactReason_BAD_ADDRESS EDAMInvalidContactReason = 0
  EDAMInvalidContactReason_DUPLICATE_CONTACT EDAMInvalidContactReason = 1
  EDAMInvalidContactReason_NO_CONNECTION EDAMInvalidContactReason = 2
)

func (p EDAMInvalidContactReason) String() string {
  switch p {
  case EDAMInvalidContactReason_BAD_ADDRESS: return "BAD_ADDRESS"
  case EDAMInvalidContactReason_DUPLICATE_CONTACT: return "DUPLICATE_CONTACT"
  case EDAMInvalidContactReason_NO_CONNECTION: return "NO_CONNECTION"
  }
  return "<UNSET>"
}

func EDAMInvalidContactReasonFromString(s string) (EDAMInvalidContactReason, error) {
  switch s {
  case "BAD_ADDRESS": return EDAMInvalidContactReason_BAD_ADDRESS, nil 
  case "DUPLICATE_CONTACT": return EDAMInvalidContactReason_DUPLICATE_CONTACT, nil 
  case "NO_CONNECTION": return EDAMInvalidContactReason_NO_CONNECTION, nil 
  }
  return EDAMInvalidContactReason(0), fmt.Errorf("not a valid EDAMInvalidContactReason string")
}


func EDAMInvalidContactReasonPtr(v EDAMInvalidContactReason) *EDAMInvalidContactReason { return &v }

func (p EDAMInvalidContactReason) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *EDAMInvalidContactReason) UnmarshalText(text []byte) error {
q, err := EDAMInvalidContactReasonFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *EDAMInvalidContactReason) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = EDAMInvalidContactReason(v)
return nil
}

func (p * EDAMInvalidContactReason) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
// This exception is thrown by EDAM procedures when a call fails as a result of
// a problem that a caller may be able to resolve.  For example, if the user
// attempts to add a note to their account which would exceed their storage
// quota, this type of exception may be thrown to indicate the source of the
// error so that they can choose an alternate action.
// 
// This exception would not be used for internal system errors that do not
// reflect user actions, but rather reflect a problem within the service that
// the user cannot resolve.
// 
// errorCode:  The numeric code indicating the type of error that occurred.
//   must be one of the values of EDAMErrorCode.
// 
// parameter:  If the error applied to a particular input parameter, this will
//   indicate which parameter. For some errors (USER_NOT_ASSOCIATED, USER_NOT_REGISTERED,
//   SSO_AUTHENTICATION_REQUIRED), this is the user's email.
// 
// Attributes:
//  - ErrorCode
//  - Parameter
type EDAMUserException struct {
  ErrorCode EDAMErrorCode `thrift:"errorCode,1,required" db:"errorCode" json:"errorCode"`
  Parameter *string `thrift:"parameter,2" db:"parameter" json:"parameter,omitempty"`
}

func NewEDAMUserException() *EDAMUserException {
  return &EDAMUserException{}
}


func (p *EDAMUserException) GetErrorCode() EDAMErrorCode {
  return p.ErrorCode
}
var EDAMUserException_Parameter_DEFAULT string
func (p *EDAMUserException) GetParameter() string {
  if !p.IsSetParameter() {
    return EDAMUserException_Parameter_DEFAULT
  }
return *p.Parameter
}
func (p *EDAMUserException) IsSetParameter() bool {
  return p.Parameter != nil
}

func (p *EDAMUserException) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetErrorCode bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetErrorCode = true
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetErrorCode{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ErrorCode is not set"));
  }
  return nil
}

func (p *EDAMUserException)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := EDAMErrorCode(v)
  p.ErrorCode = temp
}
  return nil
}

func (p *EDAMUserException)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Parameter = &v
}
  return nil
}

func (p *EDAMUserException) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("EDAMUserException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *EDAMUserException) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("errorCode", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:errorCode: ", p), err) }
  if err := oprot.WriteI32(int32(p.ErrorCode)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.errorCode (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:errorCode: ", p), err) }
  return err
}

func (p *EDAMUserException) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetParameter() {
    if err := oprot.WriteFieldBegin("parameter", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:parameter: ", p), err) }
    if err := oprot.WriteString(string(*p.Parameter)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.parameter (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:parameter: ", p), err) }
  }
  return err
}

func (p *EDAMUserException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("EDAMUserException(%+v)", *p)
}

func (p *EDAMUserException) Error() string {
  return p.String()
}

// This exception is thrown by EDAM procedures when a call fails as a result of
// a problem in the service that could not be changed through caller action.
// 
// errorCode:  The numeric code indicating the type of error that occurred.
//   must be one of the values of EDAMErrorCode.
// 
// message:  This may contain additional information about the error
// 
// rateLimitDuration:  Indicates the minimum number of seconds that an application should
//   expect subsequent API calls for this user to fail. The application should not retry
//   API requests for the user until at least this many seconds have passed. Present only
//   when errorCode is RATE_LIMIT_REACHED,
// 
// Attributes:
//  - ErrorCode
//  - Message
//  - RateLimitDuration
type EDAMSystemException struct {
  ErrorCode EDAMErrorCode `thrift:"errorCode,1,required" db:"errorCode" json:"errorCode"`
  Message *string `thrift:"message,2" db:"message" json:"message,omitempty"`
  RateLimitDuration *int32 `thrift:"rateLimitDuration,3" db:"rateLimitDuration" json:"rateLimitDuration,omitempty"`
}

func NewEDAMSystemException() *EDAMSystemException {
  return &EDAMSystemException{}
}


func (p *EDAMSystemException) GetErrorCode() EDAMErrorCode {
  return p.ErrorCode
}
var EDAMSystemException_Message_DEFAULT string
func (p *EDAMSystemException) GetMessage() string {
  if !p.IsSetMessage() {
    return EDAMSystemException_Message_DEFAULT
  }
return *p.Message
}
var EDAMSystemException_RateLimitDuration_DEFAULT int32
func (p *EDAMSystemException) GetRateLimitDuration() int32 {
  if !p.IsSetRateLimitDuration() {
    return EDAMSystemException_RateLimitDuration_DEFAULT
  }
return *p.RateLimitDuration
}
func (p *EDAMSystemException) IsSetMessage() bool {
  return p.Message != nil
}

func (p *EDAMSystemException) IsSetRateLimitDuration() bool {
  return p.RateLimitDuration != nil
}

func (p *EDAMSystemException) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetErrorCode bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetErrorCode = true
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetErrorCode{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ErrorCode is not set"));
  }
  return nil
}

func (p *EDAMSystemException)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := EDAMErrorCode(v)
  p.ErrorCode = temp
}
  return nil
}

func (p *EDAMSystemException)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Message = &v
}
  return nil
}

func (p *EDAMSystemException)  ReadField3(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.RateLimitDuration = &v
}
  return nil
}

func (p *EDAMSystemException) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("EDAMSystemException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *EDAMSystemException) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("errorCode", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:errorCode: ", p), err) }
  if err := oprot.WriteI32(int32(p.ErrorCode)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.errorCode (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:errorCode: ", p), err) }
  return err
}

func (p *EDAMSystemException) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetMessage() {
    if err := oprot.WriteFieldBegin("message", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:message: ", p), err) }
    if err := oprot.WriteString(string(*p.Message)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.message (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:message: ", p), err) }
  }
  return err
}

func (p *EDAMSystemException) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetRateLimitDuration() {
    if err := oprot.WriteFieldBegin("rateLimitDuration", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:rateLimitDuration: ", p), err) }
    if err := oprot.WriteI32(int32(*p.RateLimitDuration)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.rateLimitDuration (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:rateLimitDuration: ", p), err) }
  }
  return err
}

func (p *EDAMSystemException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("EDAMSystemException(%+v)", *p)
}

func (p *EDAMSystemException) Error() string {
  return p.String()
}

// This exception is thrown by EDAM procedures when a caller asks to perform
// an operation on an object that does not exist.  This may be thrown based on an invalid
// primary identifier (e.g. a bad GUID), or when the caller refers to an object
// by another unique identifier (e.g. a User's email address).
// 
// identifier:  A description of the object that was not found on the server.
//   For example, "Note.notebookGuid" when a caller attempts to create a note in a
//   notebook that does not exist in the user's account.
// 
// key:  The value passed from the client in the identifier, which was not
//   found. For example, the GUID that was not found.
// 
// Attributes:
//  - Identifier
//  - Key
type EDAMNotFoundException struct {
  Identifier *string `thrift:"identifier,1" db:"identifier" json:"identifier,omitempty"`
  Key *string `thrift:"key,2" db:"key" json:"key,omitempty"`
}

func NewEDAMNotFoundException() *EDAMNotFoundException {
  return &EDAMNotFoundException{}
}

var EDAMNotFoundException_Identifier_DEFAULT string
func (p *EDAMNotFoundException) GetIdentifier() string {
  if !p.IsSetIdentifier() {
    return EDAMNotFoundException_Identifier_DEFAULT
  }
return *p.Identifier
}
var EDAMNotFoundException_Key_DEFAULT string
func (p *EDAMNotFoundException) GetKey() string {
  if !p.IsSetKey() {
    return EDAMNotFoundException_Key_DEFAULT
  }
return *p.Key
}
func (p *EDAMNotFoundException) IsSetIdentifier() bool {
  return p.Identifier != nil
}

func (p *EDAMNotFoundException) IsSetKey() bool {
  return p.Key != nil
}

func (p *EDAMNotFoundException) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *EDAMNotFoundException)  ReadField1(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Identifier = &v
}
  return nil
}

func (p *EDAMNotFoundException)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Key = &v
}
  return nil
}

func (p *EDAMNotFoundException) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("EDAMNotFoundException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *EDAMNotFoundException) writeField1(oprot thrift.TProtocol) (err error) {
  if p.IsSetIdentifier() {
    if err := oprot.WriteFieldBegin("identifier", thrift.STRING, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:identifier: ", p), err) }
    if err := oprot.WriteString(string(*p.Identifier)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.identifier (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:identifier: ", p), err) }
  }
  return err
}

func (p *EDAMNotFoundException) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetKey() {
    if err := oprot.WriteFieldBegin("key", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:key: ", p), err) }
    if err := oprot.WriteString(string(*p.Key)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.key (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:key: ", p), err) }
  }
  return err
}

func (p *EDAMNotFoundException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("EDAMNotFoundException(%+v)", *p)
}

func (p *EDAMNotFoundException) Error() string {
  return p.String()
}

// An exception thrown when the provided Contacts fail validation. For instance,
// email domains could be invalid, phone numbers might not be valid for SMS,
// etc.
// 
// We will not provide individual reasons for each Contact's validation failure.
// The presence of the Contact in this exception means that the user must figure
// out how to take appropriate action to fix this Contact.
// 
// <dl>
//   <dt>contacts</dt>
//   <dd>The list of Contacts that are considered invalid by the service</dd>
// 
//   <dt>parameter</dt>
//   <dd>If the error applied to a particular input parameter, this will
//   indicate which parameter.</dd>
// 
//   <dt>reasons</dt>
//   <dd>If supplied, the list of reasons why the server considered a contact invalid,
//   matching, in order, the list returned in the contacts field.</dd>
// </dl>
// 
// Attributes:
//  - Contacts
//  - Parameter
//  - Reasons
type EDAMInvalidContactsException struct {
  Contacts []*Contact `thrift:"contacts,1,required" db:"contacts" json:"contacts"`
  Parameter *string `thrift:"parameter,2" db:"parameter" json:"parameter,omitempty"`
  Reasons []EDAMInvalidContactReason `thrift:"reasons,3" db:"reasons" json:"reasons,omitempty"`
}

func NewEDAMInvalidContactsException() *EDAMInvalidContactsException {
  return &EDAMInvalidContactsException{}
}


func (p *EDAMInvalidContactsException) GetContacts() []*Contact {
  return p.Contacts
}
var EDAMInvalidContactsException_Parameter_DEFAULT string
func (p *EDAMInvalidContactsException) GetParameter() string {
  if !p.IsSetParameter() {
    return EDAMInvalidContactsException_Parameter_DEFAULT
  }
return *p.Parameter
}
var EDAMInvalidContactsException_Reasons_DEFAULT []EDAMInvalidContactReason

func (p *EDAMInvalidContactsException) GetReasons() []EDAMInvalidContactReason {
  return p.Reasons
}
func (p *EDAMInvalidContactsException) IsSetParameter() bool {
  return p.Parameter != nil
}

func (p *EDAMInvalidContactsException) IsSetReasons() bool {
  return p.Reasons != nil
}

func (p *EDAMInvalidContactsException) Read(iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }

  var issetContacts bool = false;

  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
      issetContacts = true
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  if !issetContacts{
    return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Contacts is not set"));
  }
  return nil
}

func (p *EDAMInvalidContactsException)  ReadField1(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*Contact, 0, size)
  p.Contacts =  tSlice
  for i := 0; i < size; i ++ {
    _elem0 := &Contact{}
    if err := _elem0.Read(iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem0), err)
    }
    p.Contacts = append(p.Contacts, _elem0)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *EDAMInvalidContactsException)  ReadField2(iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Parameter = &v
}
  return nil
}

func (p *EDAMInvalidContactsException)  ReadField3(iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin()
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]EDAMInvalidContactReason, 0, size)
  p.Reasons =  tSlice
  for i := 0; i < size; i ++ {
var _elem1 EDAMInvalidContactReason
    if v, err := iprot.ReadI32(); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    temp := EDAMInvalidContactReason(v)
    _elem1 = temp
}
    p.Reasons = append(p.Reasons, _elem1)
  }
  if err := iprot.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *EDAMInvalidContactsException) Write(oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin("EDAMInvalidContactsException"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(oprot); err != nil { return err }
    if err := p.writeField2(oprot); err != nil { return err }
    if err := p.writeField3(oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *EDAMInvalidContactsException) writeField1(oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin("contacts", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:contacts: ", p), err) }
  if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Contacts)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Contacts {
    if err := v.Write(oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:contacts: ", p), err) }
  return err
}

func (p *EDAMInvalidContactsException) writeField2(oprot thrift.TProtocol) (err error) {
  if p.IsSetParameter() {
    if err := oprot.WriteFieldBegin("parameter", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:parameter: ", p), err) }
    if err := oprot.WriteString(string(*p.Parameter)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.parameter (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:parameter: ", p), err) }
  }
  return err
}

func (p *EDAMInvalidContactsException) writeField3(oprot thrift.TProtocol) (err error) {
  if p.IsSetReasons() {
    if err := oprot.WriteFieldBegin("reasons", thrift.LIST, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:reasons: ", p), err) }
    if err := oprot.WriteListBegin(thrift.I32, len(p.Reasons)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Reasons {
      if err := oprot.WriteI32(int32(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:reasons: ", p), err) }
  }
  return err
}

func (p *EDAMInvalidContactsException) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("EDAMInvalidContactsException(%+v)", *p)
}

func (p *EDAMInvalidContactsException) Error() string {
  return p.String()
}

